import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.calibration import CalibratedClassifierCV
from sklearn.utils.class_weight import compute_class_weight
from sklearn.preprocessing import StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

# Load data
merged_file_path = './metro_teams_merged.csv'
merged_data = pd.read_csv(merged_file_path)

# Select numeric columns for rolling mean (e.g., recent form)
numeric_columns = ['xGoalsFor', 'goalsFor', 'goalsAgainst']

# Calculate rolling averages for each team over recent games
rolling_stats = merged_data.groupby('team')[numeric_columns].rolling(41).mean().reset_index(drop=True)

# Add the rolling stats as new columns in the original DataFrame
for col in numeric_columns:
    merged_data[f"{col}_recent"] = rolling_stats[col]

# Now, add columns for the opponent's recent stats
merged_data['xGoalsAgainst_recent'] = merged_data['xGoalsFor_recent']
merged_data['opposingGoalsFor_recent'] = merged_data['goalsFor_recent']
merged_data['opposingGoalsAgainst_recent'] = merged_data['goalsAgainst_recent']

# Fill any NaN values generated by the rolling window
merged_data.fillna(0, inplace=True)

# Select relevant features, including team and recent form stats for both home and away teams
features = merged_data[['playerTeam', 'opposingTeam', 'home_or_away', 
                        'xGoalsFor_recent', 'goalsFor_recent', 'goalsAgainst_recent',
                        'xGoalsAgainst_recent', 'opposingGoalsFor_recent', 'opposingGoalsAgainst_recent']]

# Encode 'home_or_away' and team names
features.loc[:, 'home_or_away'] = features['home_or_away'].apply(lambda x: 1 if x == 'HOME' else 0)
features = pd.get_dummies(features, columns=['playerTeam', 'opposingTeam'])

# Define the target variable as binary outcome based on goals
merged_data['outcome'] = (merged_data['goalsFor'] > merged_data['goalsAgainst']).astype(int)
target = merged_data['outcome']

# Split data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42)

# Compute class weights for balanced training
class_weights = compute_class_weight(class_weight='balanced', classes=np.unique(target), y=target)
class_weight_dict = {i: weight for i, weight in enumerate(class_weights)}

# Standardize the numerical features to reduce home/away bias
numeric_features = ['xGoalsFor_recent', 'goalsFor_recent', 'goalsAgainst_recent',
                    'xGoalsAgainst_recent', 'opposingGoalsFor_recent', 'opposingGoalsAgainst_recent']

preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numeric_features)
    ], remainder='passthrough'
)

# Create pipeline with preprocessing and Random Forest classifier
base_model = RandomForestClassifier(random_state=42, class_weight=class_weight_dict)
calibrated_model = CalibratedClassifierCV(base_model, method='isotonic', cv=5)  # Use isotonic regression for calibration

pipeline = Pipeline([
    ('preprocessor', preprocessor),
    ('classifier', calibrated_model)
])

# Train the model
pipeline.fit(X_train, y_train)

# Update predict_odds_for_matchup function to use the pipeline

def predict_odds_for_matchup(home_team, away_team, recent_data):
    # Retrieve recent performance data for each team
    home_recent = recent_data[(recent_data['team'] == home_team)].iloc[-1]
    away_recent = recent_data[(recent_data['team'] == away_team)].iloc[-1]
    
    # Create a single row with the recent form features for both home and away teams
    sample_data = {
        'xGoalsFor_recent': [home_recent['xGoalsFor_recent']],
        'goalsFor_recent': [home_recent['goalsFor_recent']],
        'goalsAgainst_recent': [home_recent['goalsAgainst_recent']],
        'xGoalsAgainst_recent': [away_recent['xGoalsFor_recent']],
        'opposingGoalsFor_recent': [away_recent['goalsFor_recent']],
        'opposingGoalsAgainst_recent': [away_recent['goalsAgainst_recent']]
    }
    
    # Create DataFrame for the custom input
    sample_features = pd.DataFrame(sample_data)

    # Add one-hot encoding for both teams
    for team in features.columns:
        if 'playerTeam_' in team:
            sample_features[team] = 1 if team == f'playerTeam_{home_team}' else 0
        elif 'opposingTeam_' in team:
            sample_features[team] = 1 if team == f'opposingTeam_{away_team}' else 0

    # Ensure column alignment with the training set
    sample_features = sample_features.reindex(columns=X_train.columns, fill_value=0)

    # Predict calibrated win/loss probabilities for the custom input
    predicted_proba = pipeline.predict_proba(sample_features)

    # Calculate betting odds for the custom input
    epsilon = 1e-10
    margin = 1.05  
    odds_loss_custom = 1 / (predicted_proba[0][0] + epsilon)
    odds_win_custom = 1 / (predicted_proba[0][1] + epsilon)
    odds_loss_custom_with_margin = 1 / (predicted_proba[0][0] * margin + epsilon)
    odds_win_custom_with_margin = 1 / (predicted_proba[0][1] * margin + epsilon)

    # Display custom odds
    print(f"\nPredicted Odds for {home_team} (Home) vs. {away_team} (Away):")
    print(f"Odds for Home Team Loss (No Margin): {odds_loss_custom:.2f}")
    print(f"Odds for Home Team Win (No Margin): {odds_win_custom:.2f}")
    print(f"Odds for Home Team Loss (With Margin): {odds_loss_custom_with_margin:.2f}")
    print(f"Odds for Home Team Win (With Margin): {odds_win_custom_with_margin:.2f}")

# Test with calibrated model and balanced classes
predict_odds_for_matchup('NYR', 'PHI', merged_data)
